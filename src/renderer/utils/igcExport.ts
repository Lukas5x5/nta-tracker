/**
 * IGC File Export für NTA
 * IGC ist das Standardformat für Flugaufzeichnungen in der Luftfahrt
 */

import type { Flight, TrackPoint, MarkerDrop, GoalDeclaration } from '../../shared/types'

/**
 * Generiert einen IGC Dateinamen
 */
export function generateIGCFilename(flight: Flight): string {
  const date = flight.startTime
  const year = date.getFullYear().toString().slice(-2)
  const month = (date.getMonth() + 1).toString().padStart(2, '0')
  const day = date.getDate().toString().padStart(2, '0')

  // Pilot-Kürzel (erste 3 Buchstaben)
  const pilotCode = flight.pilot.substring(0, 3).toUpperCase() || 'XXX'

  // Flugnummer des Tages
  const flightNum = '1'

  return `${year}${month}${day}${pilotCode}${flightNum}.igc`
}

/**
 * Formatiert eine Koordinate im IGC Format
 * Format: DDMMmmmN/S oder DDDMMmmmE/W
 */
function formatIGCCoord(decimal: number, isLatitude: boolean): string {
  const abs = Math.abs(decimal)
  const degrees = Math.floor(abs)
  const minutes = (abs - degrees) * 60
  const minutesInt = Math.floor(minutes)
  const minutesFrac = Math.round((minutes - minutesInt) * 1000)

  const direction = isLatitude
    ? (decimal >= 0 ? 'N' : 'S')
    : (decimal >= 0 ? 'E' : 'W')

  const degPad = isLatitude ? 2 : 3

  return degrees.toString().padStart(degPad, '0') +
         minutesInt.toString().padStart(2, '0') +
         minutesFrac.toString().padStart(3, '0') +
         direction
}

/**
 * Formatiert die Zeit im IGC Format (HHMMSS)
 */
function formatIGCTime(date: Date): string {
  return date.getUTCHours().toString().padStart(2, '0') +
         date.getUTCMinutes().toString().padStart(2, '0') +
         date.getUTCSeconds().toString().padStart(2, '0')
}

/**
 * Formatiert das Datum im IGC Format (DDMMYY)
 */
function formatIGCDate(date: Date): string {
  return date.getUTCDate().toString().padStart(2, '0') +
         (date.getUTCMonth() + 1).toString().padStart(2, '0') +
         date.getUTCFullYear().toString().slice(-2)
}

/**
 * Formatiert die Höhe im IGC Format (5 Ziffern, rechtsbündig)
 */
function formatIGCAltitude(meters: number): string {
  const alt = Math.max(0, Math.round(meters))
  return alt.toString().padStart(5, '0')
}

/**
 * Generiert die A Record (Logger ID)
 */
function generateARecord(): string {
  return 'ANTA001NTA Balloon Navigator'
}

/**
 * Generiert H Records (Header)
 */
function generateHRecords(flight: Flight): string[] {
  const records: string[] = []
  const date = flight.startTime

  // Datum
  records.push(`HFDTE${formatIGCDate(date)}`)

  // Pilot
  records.push(`HFPLTPILOT:${flight.pilot}`)

  // Ballon
  if (flight.balloon) {
    records.push(`HFGTYGLIDERTYPE:${flight.balloon}`)
  }

  // GPS Genauigkeit
  records.push('HFDTM100GPSDATUM:WGS84')

  // Firmware Version
  records.push('HFFTYFRTYPE:NTA Balloon Navigator,1.0')

  // Druckhöhensensor
  records.push('HFPRSPRESSALTSENSOR:Flytec BLS')

  // GPS
  records.push('HFGPSGPS:Flytec BLS,5Hz')

  // Competition
  if (flight.competition) {
    records.push(`HFCIDCOMPETITIONID:${flight.competition}`)
  }

  return records
}

/**
 * Generiert B Records (Track Points)
 */
function generateBRecords(track: TrackPoint[]): string[] {
  return track.map(point => {
    const time = formatIGCTime(point.timestamp)
    const lat = formatIGCCoord(point.position.latitude, true)
    const lon = formatIGCCoord(point.position.longitude, false)
    const pressAlt = formatIGCAltitude(point.baro?.pressureAltitude || 0)
    const gpsAlt = formatIGCAltitude(point.position.altitude)

    // B Record Format:
    // B HHMMSS DDMMmmmN DDDMMmmmE V PPPPP GGGGG
    // V = Validity (A=3D fix, V=2D fix)
    return `B${time}${lat}${lon}A${pressAlt}${gpsAlt}`
  })
}

/**
 * Generiert E Records (Events - Marker Drops)
 */
function generateERecords(markers: MarkerDrop[]): string[] {
  return markers.map(marker => {
    const time = formatIGCTime(marker.timestamp)
    return `E${time}PEV Marker ${marker.number} dropped`
  })
}

/**
 * Generiert K Records (Extended Data - Goals)
 */
function generateKRecords(declarations: GoalDeclaration[]): string[] {
  return declarations.map(decl => {
    const time = formatIGCTime(decl.declaredAt)
    const lat = formatIGCCoord(decl.goal.position.latitude, true)
    const lon = formatIGCCoord(decl.goal.position.longitude, false)
    return `LNTAGOAL${time}${lat}${lon}${decl.goal.name}`
  })
}

/**
 * Generiert L Records (Comments)
 */
function generateLRecords(flight: Flight): string[] {
  const records: string[] = []

  records.push('LNTANOTES:Generated by NTA Balloon Navigator')

  if (flight.notes) {
    records.push(`LNTANOTES:${flight.notes}`)
  }

  return records
}

/**
 * Berechnet die IGC Checksumme (G Record)
 * Vereinfachte Version - in der Praxis wird eine kryptografische Signatur verwendet
 */
function generateGRecord(content: string): string {
  // Einfache Checksumme für Demo-Zwecke
  // Echte IGC-Validierung erfordert eine digitale Signatur
  let hash = 0
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash
  }

  const checksum = Math.abs(hash).toString(16).toUpperCase().padStart(16, '0')
  return `G${checksum}`
}

/**
 * Exportiert einen Flug als IGC Datei
 */
export function exportToIGC(flight: Flight): string {
  const lines: string[] = []

  // A Record (Logger ID)
  lines.push(generateARecord())

  // H Records (Header)
  lines.push(...generateHRecords(flight))

  // Sortiere Track Points und Events nach Zeit
  const allEvents: { time: Date; record: string }[] = []

  // B Records (Track)
  flight.track.forEach(point => {
    const time = formatIGCTime(point.timestamp)
    const lat = formatIGCCoord(point.position.latitude, true)
    const lon = formatIGCCoord(point.position.longitude, false)
    const pressAlt = formatIGCAltitude(point.baro?.pressureAltitude || 0)
    const gpsAlt = formatIGCAltitude(point.position.altitude)

    allEvents.push({
      time: point.timestamp,
      record: `B${time}${lat}${lon}A${pressAlt}${gpsAlt}`
    })
  })

  // E Records (Marker Drops)
  flight.markers.forEach(marker => {
    const time = formatIGCTime(marker.timestamp)
    allEvents.push({
      time: marker.timestamp,
      record: `E${time}PEVMarker${marker.number}`
    })
  })

  // Sortieren nach Zeit
  allEvents.sort((a, b) => a.time.getTime() - b.time.getTime())

  // Records hinzufügen
  allEvents.forEach(event => lines.push(event.record))

  // K Records (Goals)
  lines.push(...generateKRecords(flight.declarations))

  // L Records (Comments)
  lines.push(...generateLRecords(flight))

  // G Record (Security)
  const content = lines.join('\r\n')
  lines.push(generateGRecord(content))

  return lines.join('\r\n')
}

/**
 * Generiert einen Flight Report
 */
export function generateFlightReport(flight: Flight): string {
  const lines: string[] = []

  lines.push('=' .repeat(60))
  lines.push('NTA FLIGHT REPORT')
  lines.push('=' .repeat(60))
  lines.push('')

  // Flug Info
  lines.push(`Pilot: ${flight.pilot}`)
  if (flight.balloon) lines.push(`Balloon: ${flight.balloon}`)
  if (flight.competition) lines.push(`Competition: ${flight.competition}`)
  lines.push('')

  // Zeiten
  lines.push(`Start: ${flight.startTime.toISOString()}`)
  if (flight.endTime) {
    lines.push(`End: ${flight.endTime.toISOString()}`)
    const duration = (flight.endTime.getTime() - flight.startTime.getTime()) / 1000
    const hours = Math.floor(duration / 3600)
    const minutes = Math.floor((duration % 3600) / 60)
    lines.push(`Duration: ${hours}h ${minutes}m`)
  }
  lines.push('')

  // Track Statistiken
  if (flight.track.length > 0) {
    const altitudes = flight.track.map(t => t.position.altitude)
    const maxAlt = Math.max(...altitudes)
    const minAlt = Math.min(...altitudes)

    lines.push('-' .repeat(40))
    lines.push('TRACK STATISTICS')
    lines.push('-' .repeat(40))
    lines.push(`Track Points: ${flight.track.length}`)
    lines.push(`Max Altitude: ${maxAlt.toFixed(0)}m`)
    lines.push(`Min Altitude: ${minAlt.toFixed(0)}m`)
    lines.push('')
  }

  // Marker Drops
  if (flight.markers.length > 0) {
    lines.push('-' .repeat(40))
    lines.push('MARKER DROPS')
    lines.push('-' .repeat(40))
    flight.markers.forEach(marker => {
      lines.push(`#${marker.number}: ${marker.timestamp.toISOString()}`)
      lines.push(`  Position: ${marker.position.latitude.toFixed(6)}, ${marker.position.longitude.toFixed(6)}`)
      lines.push(`  Altitude: ${marker.altitude.toFixed(0)}m`)
    })
    lines.push('')
  }

  // Goal Declarations
  if (flight.declarations.length > 0) {
    lines.push('-' .repeat(40))
    lines.push('GOAL DECLARATIONS')
    lines.push('-' .repeat(40))
    flight.declarations.forEach(decl => {
      lines.push(`#${decl.number}: ${decl.goal.name}`)
      lines.push(`  Declared: ${decl.declaredAt.toISOString()}`)
      lines.push(`  Goal Position: ${decl.goal.position.latitude.toFixed(6)}, ${decl.goal.position.longitude.toFixed(6)}`)
    })
    lines.push('')
  }

  lines.push('=' .repeat(60))
  lines.push(`Generated by NTA Balloon Navigator at ${new Date().toISOString()}`)
  lines.push('=' .repeat(60))

  return lines.join('\n')
}
